import React, { useEffect, useState, useMemo } from "react";
import {
  Box,
  Checkbox,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Typography,
  Button,
  IconButton,
  Tooltip,
} from "@mui/material";
import ArrowBackIosNewIcon from "@mui/icons-material/ArrowBackIosNew";
import ArrowForwardIosIcon from "@mui/icons-material/ArrowForwardIos";

import useVulStore from "../stores/useVulStore";
import useFileStore from "../stores/useFileStore";
import KevCveTag from "./KevCveTag";
import PatchModal from "./PatchModal";
import { customAxios } from "../utils/CustomAxios";

/* =====================
   상수 / CSS
===================== */
const ROW_HEIGHT = 40;
const CHECKBOX_CELL_WIDTH = 64;
const CVE_COLUMN_WIDTH = 200;

const checkboxCellSx = {
  width: CHECKBOX_CELL_WIDTH,
  minWidth: CHECKBOX_CELL_WIDTH,
  maxWidth: CHECKBOX_CELL_WIDTH,
  padding: 0,
  textAlign: "center",
};

const headerCellSx = {
  backgroundColor: "rgb(122,25,25)",
  color: "white",
  fontWeight: "bold",
};

/* =====================
   컴포넌트
===================== */
const VulnerabilityTableComponent = () => {
  const { addFile, removeFile } = useFileStore();
  const { response, setVexReturn } = useVulStore();

  const [tableData, setTableData] = useState([]);
  const [checkedItems, setCheckedItems] = useState([]);

  /* pagination */
  const [page, setPage] = useState(0);
  const rowsPerPage = 10;

  /* patch modal */
  const [patchOpen, setPatchOpen] = useState(false);
  const [patchTarget, setPatchTarget] = useState(null);
  const [patchResult, setPatchResult] = useState([]);
  const [patchLoading, setPatchLoading] = useState(false);

  /* sorting */
  const [sortConfig, setSortConfig] = useState({
    key: null,
    direction: "asc",
  });

  /* =====================
     데이터 가공
  ===================== */
  useEffect(() => {
    if (!response?.raw_data || !Array.isArray(response.raw_data)) {
      setTableData([]);
      return;
    }

    const cveCvssMap = {};
    (response.cve_db || []).forEach(({ name, cvss }) => {
      cveCvssMap[name] = cvss;
    });

    const fileMap = {};
    response.raw_data.forEach(({ file, cveid, funcid, uniqid }) => {
      const key = `${file}-${cveid}-${funcid}`;
      if (!fileMap[key]) {
        fileMap[key] = {
          file,
          cve: cveid,
          funcid,
          cvss: cveCvssMap[cveid] ?? "0.0",
          uniqid,
        };
      }
    });

    setTableData(Object.values(fileMap));
  }, [response]);

  /* =====================
     체크 → VEX 반환
  ===================== */
  useEffect(() => {
    if (!response?.raw_data) return;

    const filtered = response.raw_data.filter((item) =>
      checkedItems.some(
        (c) =>
          c.file === item.file &&
          c.cve === item.cveid &&
          c.funcid === item.funcid
      )
    );

    setVexReturn({ raw_data: filtered });
  }, [checkedItems, response, setVexReturn]);

  /* =====================
     API
  ===================== */
  const fetchVdbByFilename = async (filename) => {
    const res = await customAxios.get("/api/search/vdb/search/desc/file-name", {
      params: { filename },
    });
    return Array.isArray(res.data) ? res.data : [];
  };

  /* =====================
     체크박스
  ===================== */
  const handleCheckboxChange = (file) => {
    if (checkedItems.includes(file)) {
      setCheckedItems((prev) => prev.filter((i) => i !== file));
      removeFile(file);
    } else {
      setCheckedItems((prev) => [...prev, file]);
      addFile(file);
    }
  };

  const isAllChecked =
    tableData.length > 0 &&
    tableData.every((file) =>
      checkedItems.some(
        (i) =>
          i.file === file.file && i.cve === file.cve && i.funcid === file.funcid
      )
    );

  const handleAllCheck = (e) => {
    if (e.target.checked) {
      setCheckedItems(tableData);
      tableData.forEach(addFile);
    } else {
      setCheckedItems([]);
      tableData.forEach(removeFile);
    }
  };

  /* =====================
     정렬 (CVSS 클릭)
  ===================== */
  const handleSortCvss = () => {
    setSortConfig((prev) => ({
      key: "cvss",
      direction: prev.direction === "asc" ? "desc" : "asc",
    }));
  };

  const sortedData = useMemo(() => {
    const sorted = [...tableData];
    if (sortConfig.key === "cvss") {
      sorted.sort((a, b) => {
        const aScore = Number(a.cvss) || 0;
        const bScore = Number(b.cvss) || 0;
        return sortConfig.direction === "asc"
          ? aScore - bScore
          : bScore - aScore;
      });
    }
    return sorted;
  }, [tableData, sortConfig]);

  /* =====================
     페이지네이션
  ===================== */
  const totalPages = Math.ceil(sortedData.length / rowsPerPage);
  const currentPageData = sortedData.slice(
    page * rowsPerPage,
    page * rowsPerPage + rowsPerPage
  );

  const renderPageButtons = () => {
    const btnNum = 10;
    const start = Math.floor(page / btnNum) * btnNum;
    const end = Math.min(totalPages, start + btnNum);

    return Array.from({ length: end - start }, (_, i) => {
      const p = start + i;
      return (
        <Button
          key={p}
          onClick={() => setPage(p)}
          variant="contained"
          sx={{
            width: 40,
            minWidth: 40,
            backgroundColor: p === page ? "rgb(134,32,32)" : "rgb(194,62,62)",
            color: p === page ? "white" : "black",
          }}
        >
          {p + 1}
        </Button>
      );
    });
  };

  /* =====================
     렌더 유틸
  ===================== */
  const renderCvssTag = (cvss) => {
    const score = Number(cvss);
    let bg = "#9e9e9e";
    let text = "#fff";

    if (!Number.isNaN(score)) {
      if (score >= 9.0) bg = "#7b1fa2";
      else if (score >= 7.0) bg = "#d32f2f";
      else if (score >= 4.0) {
        bg = "#fbc02d";
        text = "#000";
      } else if (score > 0) bg = "#388e3c";
    }

    return (
      <Box
        sx={{
          px: 1.5,
          py: 0.5,
          borderRadius: "12px",
          backgroundColor: bg,
          color: text,
          fontSize: 12,
          fontWeight: "bold",
          minWidth: 60,
          textAlign: "center",
        }}
      >
        {Number.isNaN(score) ? "N/A" : score.toFixed(1)}
      </Box>
    );
  };

  /* =====================
     cvss 태그 
  ===================== */
  const renderCvssLegend = () => {
    const legend = [
      {
        label: "Critical",
        range: "9.0 – 10.0",
        bg: "#7b1fa2",
        text: "#fff",
      },
      {
        label: "High",
        range: "7.0 – 8.9",
        bg: "#d32f2f",
        text: "#fff",
      },
      {
        label: "Medium",
        range: "4.0 – 6.9",
        bg: "#fbc02d",
        text: "#000",
      },
      {
        label: "Low",
        range: "0.1 – 3.9",
        bg: "#388e3c",
        text: "#fff",
      },
      {
        label: "Unknown",
        range: "N/A",
        bg: "#9e9e9e",
        text: "#fff",
      },
    ];

    return (
      <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap" }}>
        {legend.map((item) => (
          <Tooltip key={item.label} title={`CVSS ${item.range}`} arrow>
            <Box
              sx={{
                px: 1.5,
                py: 0.5,
                borderRadius: "14px",
                backgroundColor: item.bg,
                color: item.text,
                fontSize: "12px",
                fontWeight: "bold",
                lineHeight: 1,
                cursor: "default",
              }}
            >
              {item.label}
            </Box>
          </Tooltip>
        ))}
      </Box>
    );
  };

  const renderPatchButton = (file) => (
    <Button
      size="small"
      variant="contained"
      onClick={async () => {
        try {
          setPatchTarget(file);
          setPatchOpen(true);
          setPatchLoading(true);

          const processed = file.uniqid.substring(file.uniqid.indexOf("CVE-"));

          const data = await fetchVdbByFilename(processed);
          setPatchResult(data);
        } catch {
          setPatchResult([]);
        } finally {
          setPatchLoading(false);
        }
      }}
    >
      PATCH
    </Button>
  );

  /* =====================
     VUDDY Vulnerability Table
  ===================== */
  return (
    <>
      <Box sx={{ p: 2 }}>
        {/* 헤더 */}
        <Box
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "flex-end", // ✅ 세로 바닥 정렬
          }}
        >
          <Typography variant="h6">VUDDY Vulnerable Files</Typography>

          <Box sx={{ mb: 0.5 }}>{renderCvssLegend()}</Box>
        </Box>

        {/* 테이블 */}
        <TableContainer component={Paper} sx={{ maxHeight: 500 }}>
          <Table stickyHeader size="small">
            <TableHead>
              <TableRow>
                <TableCell sx={headerCellSx} align="center">
                  ID
                </TableCell>
                <TableCell sx={headerCellSx}>File Path</TableCell>
                <TableCell
                  sx={{ ...headerCellSx, width: CVE_COLUMN_WIDTH }}
                  align="center"
                >
                  CVE
                </TableCell>
                <TableCell
                  sx={{ ...headerCellSx, cursor: "pointer" }}
                  align="center"
                  onClick={handleSortCvss}
                >
                  CVSS {sortConfig.direction === "asc" ? "▲" : "▼"}
                </TableCell>
                <TableCell sx={headerCellSx} align="center">
                  PATCH
                </TableCell>
                <TableCell sx={headerCellSx} align="center">
                  KEV
                </TableCell>
                <TableCell sx={headerCellSx}>
                  <Checkbox checked={isAllChecked} onChange={handleAllCheck} />
                </TableCell>
              </TableRow>
            </TableHead>

            <TableBody>
              {currentPageData.map((file, idx) => (
                <TableRow key={`${file.file}-${file.funcid}-${idx}`}>
                  <TableCell align="center">
                    {page * rowsPerPage + idx + 1}
                  </TableCell>
                  <TableCell>{file.file}</TableCell>
                  <TableCell align="center" sx={{ width: CVE_COLUMN_WIDTH }}>
                    {file.cve}
                  </TableCell>
                  <TableCell align="center">
                    {renderCvssTag(file.cvss)}
                  </TableCell>
                  <TableCell align="center">
                    {renderPatchButton(file)}
                  </TableCell>
                  <TableCell align="center">
                    <KevCveTag cveId={file.cve} />
                  </TableCell>
                  <TableCell sx={checkboxCellSx}>
                    <Checkbox
                      checked={checkedItems.includes(file)}
                      onChange={() => handleCheckboxChange(file)}
                    />
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>

        <Box
          sx={{
            mt: 2,
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
          }}
        >
          <IconButton onClick={() => setPage(page - 1)} disabled={page === 0}>
            <ArrowBackIosNewIcon />
          </IconButton>

          <Box sx={{ display: "flex", gap: 0.5 }}>{renderPageButtons()}</Box>

          <IconButton
            onClick={() => setPage(page + 1)}
            disabled={page >= totalPages - 1}
          >
            <ArrowForwardIosIcon />
          </IconButton>
        </Box>
      </Box>

      {/* PATCH MODAL */}
      <PatchModal
        open={patchOpen}
        onClose={() => {
          setPatchOpen(false);
          setPatchTarget(null);
          setPatchResult([]);
        }}
        patchTarget={patchTarget}
        patchResult={patchResult}
        patchLoading={patchLoading}
      />
    </>
  );
};

export default VulnerabilityTableComponent;
